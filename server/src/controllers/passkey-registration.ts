import {
  generateRegistrationOptions,
  verifyRegistrationResponse,
} from '@simplewebauthn/server';
import { isoBase64URL } from '@simplewebauthn/server/helpers';
import { rpName, rpID, origin } from '../utils/passkeys-constants.js';
import { credentialService } from '../models/passkeys-credential-service.js';
import { userService } from '../models/passkeys-user-service.js';
import type { GenerateRegistrationOptionsOpts } from '@simplewebauthn/server';
import type { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middlewares/customError.js';

// below function initiates the passkey registration, it generates a challenge that is sent
// to the user for him/her to sign it
export const handleRegisterStart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const { email } = req.body;

  // Add email validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!email || !emailRegex.test(email)) {
    return next(new CustomError('Invalid email format', 400));
  }

  try {
    // case when user has already previously registered (with either password or passkey)
    let user = await userService.getUserByEmail(email);
    // if new user:
    if (!user) {
      user = await userService.createUser(email);
    }

    const registrationOptions: GenerateRegistrationOptionsOpts = {
      rpName,
      rpID,
      userID: new Uint8Array(Buffer.from(user.id.toString())), // Convert number to string
      userName: user.email,
      timeout: 60000, // time limit (in milliseconds) the registration process will wait for the user to complete the action (tap security key or use biometrics)
      attestationType: 'none',
      authenticatorSelection: {
        residentKey: 'required', // authenticator is required to store a resident key
        userVerification: 'preferred', // specifies whether authenticator should perform user verification (e.g., biometrics or PIN) during registration
        authenticatorAttachment: 'platform', // specifies the type of authenticator the server prefers
      },
      // Support for the two most common algorithms: ES256, and RS256
      supportedAlgorithmIDs: [-7, -257],
    };

    const options = await generateRegistrationOptions(registrationOptions);

    // challenge is sent to authenticator (to confirm user)
    req.session.loggedInUserId = user.id;
    req.session.currentChallenge = options.challenge;

    res.locals.options = options;
    next();
  } catch (error) {
    console.error('Registration error details:', error);
    if (error instanceof Error) {
      console.error('Error name:', error.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }

    next(
      error instanceof CustomError
        ? error
        : new CustomError('Internal Server Error', 500)
    );
  }
};

// server receives the signed challenged from the user (from frontend code)
// and stores a credential_id (generated by the authenticator)
// and a public_key in the database (cryptographic public key generated by the authenticator during registration - used to verify signatures during authentication)
// (the private key is stored securely in the authenticator)
export const handleRegisterFinish = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const { body } = req;
  const { currentChallenge, loggedInUserId } = req.session;

  if (!loggedInUserId) {
    return next(new CustomError('User ID is missing', 400));
  }

  if (!currentChallenge) {
    return next(new CustomError('Current challenge is missing', 400));
  }

  try {
    const verification = await verifyRegistrationResponse({
      response: body,
      expectedChallenge: currentChallenge,
      expectedOrigin: origin,
      expectedRPID: rpID,
      requireUserVerification: true,
    });

    if (verification.verified && verification.registrationInfo) {
      const { credential } = verification.registrationInfo;

      const credentialIdBase64 = isoBase64URL.toBase64(credential.id);

      try {
        await credentialService.saveNewCredential(
          parseInt(loggedInUserId),
          credentialIdBase64,
          Buffer.from(credential.publicKey).toString('base64'),
          credential.counter,
          credential.transports || [],
          verification.registrationInfo.fmt || 'none'
        );

        res.locals.verified = true;
        next();
      } catch (error) {
        console.error('Error saving credential:', error);
        next(new CustomError('Failed to save credential', 500));
      }
    } else {
      next(new CustomError('Verification failed', 400));
    }
  } catch (error) {
    next(
      error instanceof CustomError
        ? error
        : new CustomError('Internal Server Error', 500)
    );
  } finally {
    req.session.loggedInUserId = undefined;
    req.session.currentChallenge = undefined;
  }
};
